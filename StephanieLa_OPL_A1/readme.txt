*****************************************************************************
Name: Stephanie La
Group Members: Demetri Cassidy, Josh Sullivan, Stephanie La

Languages used: Python (our own code), Ada, Ocaml, Go, Prolog

1. I think the easier langauges to work with was Python, Go,
and Ocaml. I think the syntax for Python was similar to C or C++
syntax, however there were some places where a semicolon was not 
necessary. Go was written pretty similar like C++, and I could 
understand the code easily and what it was trying to convey. 
Ocaml was also similarly written, but using the words in, let,
and done were new to me. A for loop was implemented similarly 
to the familiarity of a C++/ C program. Overall, I think the 
3 of those languages were similar to C/C++.
	
2. I think the harder lanauges that took a bit more time to 
understand were Prolog and Ada. Prolog was a bit hard to figure
out, the syntax was nothing like I've ever seen before, a alot 
of the function parameters were multiplied or added together to
form a resulting parameter, and that parameter was given into 
another function for another subproblem. Ada was confusing since
we found out we had to separate the Ada code into 3 separate files 
in order to compile and run the code correctly. It was the equivalent
of separating a hpp, cpp and main file of a C/C++ program. Ada and 
Prolog language syntax were a bit more wordy than other langauges. 
Often using "ranges" instead of using loops to define limits.


3. When running all the langauges, all of them compiled and ran 
efficinely with no lag. Ada took a bit longer to compile and run
but there were no other observable differences. Due to the Ada 
code containing 3 separate files, it may have taken longer to compile.

4. I liked the simplicity and the structure of Go, Python, and Ocaml. It
was easier to comment and write. Maybe I was just used to the structure of 
C/C++ that it made it easier to read these programs. It was less wordy, and 
more symbols were used to represent words in substitution. Ada and Prolog 
were too wordy for my liking, and it was very hard to detetct the flow of 
code in Prolog. When Ada was making for loops, I could identify what was 
being written and when loops were done.

5. In Python, the data was stored in lists and used those lists to multiply 
through y's rows and columns and then add up the products in the current 
square at the end of the loop. In Go, the data was stored in arrays and then
multiplied together instead of multiplying a row and then column, since they
are already separate arrays that could represent either of them. In Ada,
the data was stored as a list just like Python in order to multiply columns 
and rows by each other. In Ocaml, the data was stored in arrays and multiplied 
together in separate x and y length and height. In Prolog, the data was stored 
as lists to trapose and multiply each list together and pass the result on to
other helper functions.

*****************************************************************************
